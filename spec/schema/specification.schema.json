{
  "$ref": "#/definitions/ComponentSpec",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Affordance": {
      "description": "Union type of all available affordance types",
      "anyOf": [
        {
          "$ref": "#/definitions/VirtualisationAffordance"
        },
        {
          "$ref": "#/definitions/SortingAffordance"
        },
        {
          "$ref": "#/definitions/FilteringAffordance"
        },
        {
          "$ref": "#/definitions/PaginationAffordance"
        },
        {
          "$ref": "#/definitions/ExportAffordance"
        },
        {
          "$ref": "#/definitions/SelectionAffordance"
        },
        {
          "$ref": "#/definitions/SearchAffordance"
        }
      ],
      "discriminator": {
        "propertyName": "type",
        "mapping": {
          "virtualisation": "#/definitions/VirtualisationAffordance",
          "sorting": "#/definitions/SortingAffordance",
          "filtering": "#/definitions/FilteringAffordance",
          "pagination": "#/definitions/PaginationAffordance",
          "export": "#/definitions/ExportAffordance",
          "selection": "#/definitions/SelectionAffordance",
          "search": "#/definitions/SearchAffordance"
        }
      }
    },
    "VirtualisationAffordance": {
      "description": "Enables efficient rendering of large datasets by only rendering visible items.\n\nVirtualisation is critical for performance when displaying thousands of rows. The rendering engine only creates DOM nodes for items in/near the viewport, dramatically reducing memory usage and initial render time.\n\nUse this for: large tables, long lists, infinite scrolling",
      "additionalProperties": false,
      "properties": {
        "buffer_size": {
          "type": "number",
          "description": "Maximum number of items to keep in rendered memory. Items beyond this are unmounted to prevent memory leaks. Default: 50"
        },
        "item_height": {
          "type": "number",
          "description": "Fixed height for each item in pixels. Required for optimal performance with fixed-height rows. Omit this for dynamic-height items (slower but more flexible)"
        },
        "overscan_count": {
          "type": "number",
          "description": "Number of items to render outside the visible viewport. Higher values provide smoother scrolling but use more memory. Default: 3"
        },
        "type": {
          "const": "virtualisation",
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "SortingAffordance": {
      "description": "Enables sorting data by one or more fields. Allows sorting data ascending/descending by field values. Sorting can be restricted to specific fields or allowed on all fields",
      "additionalProperties": false,
      "properties": {
        "allowed_fields": {
          "items": {
            "$ref": "#/definitions/AffordedField"
          },
          "type": "array",
          "description": "Fields that can be sorted. Omit to allow sorting on all fields in the component"
        },
        "default_direction": {
          "enum": [
            "asc",
            "desc"
          ],
          "type": "string",
          "description": "Initial sort direction. Default: 'asc'"
        },
        "default_field": {
          "$ref": "#/definitions/AffordedField"
        },
        "type": {
          "const": "sorting",
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "FilteringAffordance": {
      "description": "Enables filtering data based on field values.\n\nSupports both simple single-field filters and complex multi-condition queries using logical operators.\n\nFilter behaviour:\n- Multiple default_filters are combined with AND logic\n- User can add/remove filters interactively\n- Filter types determine appropriate interaction patterns",
      "additionalProperties": false,
      "properties": {
        "allowed_fields": {
          "items": {
            "$ref": "#/definitions/AffordedField"
          },
          "type": "array",
          "description": "Fields that can be filtered. Omit to allow filtering on all fields in the component"
        },
        "default_filters": {
          "items": {
            "$ref": "#/definitions/FilterCondition"
          },
          "type": "array",
          "description": "Filters applied by default when component first renders. Useful for pre-filtering data to a relevant subset. User can modify/remove these filters interactively"
        },
        "filter_types": {
          "additionalProperties": {
            "$ref": "#/definitions/FilterType"
          },
          "type": "object",
          "description": "Specifies the filter interaction type for each field. Maps field accessor to FilterType (e.g., {'age': 'number_range', 'name': 'text'}). Omit to auto-detect based on data types from FieldMetadata"
        },
        "type": {
          "const": "filtering",
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "PaginationAffordance": {
      "description": "Enables paginated display of data with configurable page sizes.\n\nPagination improves performance and usability for large datasets by displaying data in manageable chunks. Users can navigate between pages and optionally adjust the page size.\n\nNote: Pagination and virtualisation serve different purposes:\n- Use pagination for traditional page-based navigation\n- Use virtualisation for continuous scrolling or very large datasets\n- They can be combined (paginated + virtualised pages)",
      "additionalProperties": false,
      "properties": {
        "page_size": {
          "type": "number",
          "description": "Default number of items displayed per page"
        },
        "show_size_options": {
          "type": "boolean",
          "description": "Whether to allow users to change page size. Default: true"
        },
        "size_options": {
          "items": {
            "type": "number"
          },
          "type": "array",
          "description": "Available page size options. Default: [10, 25, 50, 100]"
        },
        "type": {
          "const": "pagination",
          "type": "string"
        }
      },
      "required": [
        "type",
        "page_size"
      ],
      "type": "object"
    },
    "ExportAffordance": {
      "description": "Enables exporting data to various file formats.\n\nProvides ability to export visible or filtered data. Export respects current filters and sorting but typically exports ALL matching data (not just the current page)",
      "additionalProperties": false,
      "properties": {
        "filename_template": {
          "type": "string",
          "description": "Template for generated filename. Supports placeholders: {title}, {timestamp}, {date}. Default: '{title}_{timestamp}'"
        },
        "formats": {
          "items": {
            "$ref": "#/definitions/ExportAffordanceFormat"
          },
          "type": "array",
          "description": "Available export formats (e.g., ['csv', 'json'])"
        },
        "include_headers": {
          "type": "boolean",
          "description": "Whether to include column headers in exported files. Default: true"
        },
        "type": {
          "const": "export",
          "type": "string"
        }
      },
      "required": [
        "type",
        "formats"
      ],
      "type": "object"
    },
    "SelectionAffordance": {
      "description": "Enables interactive selection of rows/items. Allows selecting data rows, useful for bulk actions, detail views, or highlighting items of interest",
      "additionalProperties": false,
      "properties": {
        "mode": {
          "enum": [
            "single",
            "multiple"
          ],
          "type": "string",
          "description": "Selection mode: 'single' (only one item can be selected at a time) or 'multiple' (multiple items can be selected simultaneously)"
        },
        "preserve_across_pages": {
          "type": "boolean",
          "description": "Whether selections persist when navigating between pages. Default: false (selections reset on page change)"
        },
        "show_selection_indicators": {
          "type": "boolean",
          "description": "Whether to provide explicit selection indicators. Default: true for multiple mode, false for single mode"
        },
        "type": {
          "const": "selection",
          "type": "string"
        }
      },
      "required": [
        "type",
        "mode"
      ],
      "type": "object"
    },
    "SearchAffordance": {
      "description": "Enables full-text search across data fields.\n\nFilters data to matching rows based on text queries. Search is typically less structured than filtering but more convenient for quick queries.\n\nSearch vs Filter:\n- Search: Quick, text-based, searches across multiple fields\n- Filter: Structured, field-specific, supports complex conditions",
      "additionalProperties": false,
      "properties": {
        "case_sensitive": {
          "type": "boolean",
          "description": "Whether search is case-sensitive. Default: false (case-insensitive)"
        },
        "min_characters": {
          "type": "number",
          "description": "Minimum number of characters before search activates. Prevents expensive searches on very short inputs. Default: 1"
        },
        "searchable_fields": {
          "items": {
            "$ref": "#/definitions/AffordedField"
          },
          "type": "array",
          "description": "Fields to search within. Omit to search all text fields in the component"
        },
        "type": {
          "const": "search",
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "ComponentConfig": {
      "description": "Discriminated union of all component configuration types",
      "anyOf": [
        {
          "$ref": "#/definitions/DataTableConfig"
        },
        {
          "$ref": "#/definitions/HierarchyConfig"
        },
        {
          "$ref": "#/definitions/CompositionConfig"
        },
        {
          "$ref": "#/definitions/TextInsightConfig"
        }
      ],
      "discriminator": {
        "propertyName": "type",
        "mapping": {
          "data-table": "#/definitions/DataTableConfig",
          "hierarchy": "#/definitions/HierarchyConfig",
          "composition": "#/definitions/CompositionConfig",
          "text-insight": "#/definitions/TextInsightConfig"
        }
      }
    },
    "DataTableColumn": {
      "description": "Column configuration for data table components.\n\nDefines display properties for a single column. The accessor references a field in accessor_bindings, linking display config to data semantics.\n\nColumn order in the array determines display order (left-to-right).\n\nSortability and filterability are derived from affordances, not defined per-column.",
      "additionalProperties": false,
      "properties": {
        "accessor": {
          "type": "string",
          "description": "JSONPath accessor referencing a field in accessor_bindings. Examples: 'name', 'user.email', 'metadata.created_at'"
        },
        "label": {
          "type": "string",
          "description": "Human-readable column header text"
        },
        "width": {
          "$ref": "#/definitions/SizeConstraint"
        },
        "alignment": {
          "type": "string",
          "enum": [
            "left",
            "center",
            "right"
          ],
          "description": "Horizontal alignment of cell content. Default: 'left' for text, 'right' for numbers"
        },
        "visible": {
          "type": "boolean",
          "description": "Whether the column is visible. Hidden columns remain in the spec but are not rendered. Default: true"
        },
        "description": {
          "type": "string",
          "description": "Optional description for tooltip or help text"
        }
      },
      "required": [
        "accessor",
        "label"
      ],
      "type": "object"
    },
    "DataTableConfig": {
      "description": "Configuration for data table components.\n\nData tables display tabular data with rows and columns, supporting common tabular operations like sorting, filtering, and pagination.\n\nBest used with: data_shape = 'tabular'",
      "additionalProperties": false,
      "properties": {
        "affordances": {
          "items": {
            "$ref": "#/definitions/Affordance"
          },
          "type": "array",
          "description": "Interactive capabilities enabled for this table. Common affordances: sorting, filtering, pagination, virtualisation, search, export"
        },
        "columns": {
          "items": {
            "$ref": "#/definitions/DataTableColumn"
          },
          "type": "array",
          "description": "Column definitions specifying which fields to display and how to render them. Column order determines display order (left-to-right). Each column's accessor must reference a field in accessor_bindings"
        },
        "description": {
          "type": "string",
          "description": "Optional description explaining the component's purpose"
        },
        "title": {
          "type": "string",
          "description": "Optional title for the component"
        },
        "type": {
          "const": "data-table",
          "type": "string"
        }
      },
      "required": [
        "affordances",
        "columns",
        "type"
      ],
      "type": "object"
    },
    "HierarchyConfig": {
      "description": "Configuration for hierarchy/tree components.\n\nHierarchy components display nested or tree-structured data with expand/collapse functionality and hierarchical navigation.\n\nBest used with: data_shape = 'hierarchical'",
      "additionalProperties": false,
      "properties": {
        "affordances": {
          "items": {
            "$ref": "#/definitions/Affordance"
          },
          "type": "array",
          "description": "Interactive capabilities enabled for this hierarchy. Common affordances: search, selection, export"
        },
        "description": {
          "type": "string",
          "description": "Optional description explaining the component's purpose"
        },
        "title": {
          "type": "string",
          "description": "Optional title for the component"
        },
        "type": {
          "const": "hierarchy",
          "type": "string"
        }
      },
      "required": [
        "affordances",
        "type"
      ],
      "type": "object"
    },
    "CompositionConfig": {
      "description": "Configuration for composition components.\n\nCompositions are meta-components that combine multiple sub-components into a unified visualisation (e.g., a dashboard with multiple charts).\n\nBest used with: any data_shape, depending on sub-components",
      "additionalProperties": false,
      "properties": {
        "affordances": {
          "items": {
            "$ref": "#/definitions/Affordance"
          },
          "type": "array",
          "description": "Interactive capabilities for the composition as a whole. Note: sub-components have their own affordances"
        },
        "description": {
          "type": "string",
          "description": "Optional description explaining the component's purpose"
        },
        "title": {
          "type": "string",
          "description": "Optional title for the component"
        },
        "type": {
          "const": "composition",
          "type": "string"
        }
      },
      "required": [
        "affordances",
        "type"
      ],
      "type": "object"
    },
    "TextInsightConfig": {
      "description": "Configuration for text insight components.\n\nText insights display textual information, summaries, or key-value metadata in a readable format.\n\nBest used with: data_shape = 'key_value'",
      "additionalProperties": false,
      "properties": {
        "affordances": {
          "items": {
            "$ref": "#/definitions/Affordance"
          },
          "type": "array",
          "description": "Interactive capabilities for text insights. Common affordances: search, export"
        },
        "description": {
          "type": "string",
          "description": "Optional description explaining the component's purpose"
        },
        "title": {
          "type": "string",
          "description": "Optional title for the component"
        },
        "type": {
          "const": "text-insight",
          "type": "string"
        }
      },
      "required": [
        "affordances",
        "type"
      ],
      "type": "object"
    },
    "ComponentSpec": {
      "additionalProperties": false,
      "description": "Sigil Component Specification - Intermediate Representation\n\nDesign principles:\n- Specs are generated fresh for each dataset, tailored to its semantic meaning\n- Field metadata, value mappings, and bindings are embedded directly in the spec\n- Data values are provided separately at render time (not embedded in spec)\n- Layout and components are separate concerns\n- Type-specific configs via discriminated unions\n- Everything normalised to JSON before spec generation\n\nSpecs are generated fresh for each dataset by LLMs or spec generators, tailored to the specific semantic meaning and structure of that data. Even datasets with identical shapes may require different specs if their semantic meaning differs.\n\nThe spec contains everything needed to render the visualisation:\n- Layout structure and component arrangement\n- Component configurations and affordances\n- Field metadata, type information, and value mappings\n- Data shape and structural expectations\n\nThe spec does NOT contain the actual data values - those are provided separately at render time. This separation allows:\n- Lightweight serialisation and storage of specs\n- Rendering different views of the same dataset (filtered, paginated, etc.)\n- Versioning and evolution of specs independently from data\n\nThe spec is immutable once created - any modifications create a new version.",
      "properties": {
        "created_at": {
          "type": "string",
          "description": "ISO 8601 timestamp of when this spec was created. Format: YYYY-MM-DDTHH:mm:ss.sssZ"
        },
        "data_shape": {
          "$ref": "#/definitions/DataShape"
        },
        "description": {
          "type": "string",
          "description": "Optional description explaining the purpose or usage of this spec"
        },
        "id": {
          "type": "string",
          "description": "Unique identifier for this specification (UUID v4 recommended)"
        },
        "root": {
          "$ref": "#/definitions/Component",
          "description": "The root node containing the full layout, components, and field bindings. This encapsulates the entire visualisation specification. The rendering engine starts here to build the UI"
        },
        "title": {
          "type": "string",
          "description": "Human-readable title for the visualisation"
        }
      },
      "required": [
        "id",
        "title",
        "created_at",
        "data_shape",
        "root"
      ],
      "type": "object"
    },
    "Component": {
      "additionalProperties": false,
      "description": "A complete component specification including layout, components, and field bindings. This is the root structure used by the rendering engine to build a component in the UI",
      "properties": {
        "accessor_bindings": {
          "additionalProperties": {
            "additionalProperties": {
              "$ref": "#/definitions/FieldMetadata"
            },
            "type": "object"
          },
          "type": "object",
          "description": "Field metadata providing semantic information about data fields for each component.\n\nStructure: {[component_id]: {[field_accessor]: FieldMetadata } }\n\nThis maps each component's fields to their metadata (types, roles, display hints, value mappings). The component_id keys correspond to IDs in ComponentSpec.components. The field_accessor keys use dot notation matching AffordedField.accessor syntax.\n\nField metadata includes:\n- Semantic roles (label, value, category, etc.)\n- Data types with fallback options for coercion\n- Value mappings for transforming raw values to display values\n- Format strings for dates and numbers\n\nExample:\n{\n  \"table-1\": {\n    \"user.name\": {roles: [\"label\"], data_types: [\"string\"], ...},\n    \"user.age\": {roles: [\"value\"], data_types: [\"number\"], format: \"0,0\", ...}\n  }\n}"
        },
        "layout": {
          "$ref": "#/definitions/LayoutNode"
        },
        "nodes": {
          "additionalProperties": {
            "$ref": "#/definitions/ComponentNode"
          },
          "type": "object",
          "description": "Registry of all component nodes used in this component, keyed by component ID. Using a Record ensures O(1) lookup performance and guarantees ID uniqueness. Components are referenced from LayoutChild nodes via their IDs"
        }
      },
      "required": [
        "layout",
        "nodes",
        "accessor_bindings"
      ],
      "type": "object"
    },
    "ComponentNode": {
      "additionalProperties": false,
      "description": "A ComponentNode is a leaf node in the layout tree that renders data.\n\nComponentNodes are stored in Component.nodes and referenced from LayoutChild nodes via their IDs. This separation enables:\n- Component reuse across multiple layout positions\n- Centralised component configuration\n- Efficient lookups without tree traversal",
      "properties": {
        "config": {
          "$ref": "#/definitions/ComponentConfig"
        },
        "id": {
          "type": "string",
          "description": "Unique identifier for this component. Referenced by LayoutChild.component_id"
        },
        "type": {
          "$ref": "#/definitions/ComponentType"
        }
      },
      "required": [
        "id",
        "type",
        "config"
      ],
      "type": "object"
    },
    "FieldMetadata": {
      "description": "Metadata describing how a data field should be interpreted and displayed.\n\nFieldMetadata provides the semantic layer between raw data and visualisation. It tells the rendering engine:\n- What role(s) the field plays (e.g., label, value, time axis)\n- What data type(s) it contains (with fallbacks for type coercion)\n- How to transform values for display (mappings)\n- How to format values (date/number formatting)",
      "additionalProperties": false,
      "properties": {
        "data_types": {
          "items": {
            "$ref": "#/definitions/DataType"
          },
          "type": "array",
          "description": "Data types for this field, in order of preference. First element is the primary type, subsequent elements are fallbacks for type coercion if the primary type fails. Example: ['number', 'string'] means 'try to parse as number, fall back to string'"
        },
        "format": {
          "type": "string",
          "description": "Format string for displaying values. Uses format strings appropriate to the data type:\n- Dates: 'DD/MM/YYYY', 'YYYY-MM-DD HH:mm:ss', 'MMM D, YYYY'\n- Numbers: '0,0.00', '£0,0', '$0.00a', '0%'\n- Strings: typically omitted (displayed as-is)\n\nThe rendering engine determines how to interpret format strings"
        },
        "roles": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Semantic roles this field plays in the visualisation. Always an array to support fields with multiple roles.\n\nCommon roles:\n- 'label': Human-readable identifier (e.g., name, title)\n- 'value': Numeric or quantitative data\n- 'time': Temporal data for time-series\n- 'x', 'y': Positional data for charts\n- 'category': Categorical grouping\n- 'id': Unique identifier\n\nExample: ['x', 'time'] for a time-series x-axis"
        },
        "value_mappings": {
          "additionalProperties": {
            "$ref": "#/definitions/ValueMapping"
          },
          "type": "object",
          "description": "Mappings from source values to display values. Maps raw data values to ValueMapping objects that define how to display them. Keys are the source values (as strings), values are the display transformations.\n\nExample:\n{\n  '0': { display_value: 'Inactive', display_config: { type: 'chip', details: { color: 'grey' } } },\n  '1': { display_value: 'Active', display_config: { type: 'chip', details: { color: 'green' } } }\n}"
        }
      },
      "required": [
        "roles",
        "data_types"
      ],
      "type": "object"
    },
    "ValueMapping": {
      "description": "Defines how a raw data value should be displayed.\n\nValue mappings transform source values into human-readable display values with optional visual styling. Common use cases:\n- Status codes: 0 → 'Pending' (yellow chip), 1 → 'Complete' (green chip)\n- Boolean flags: true → 'Yes' (green label), false → 'No' (red label)\n- Categories: 'cat_a' → 'Category A' (blue badge)\n\nThe source value is the key in FieldMetadata.value_mappings, and this ValueMapping is the corresponding value",
      "additionalProperties": false,
      "properties": {
        "display_config": {
          "$ref": "#/definitions/ValueMappingDisplayConfig",
          "description": "Optional visual styling for the display value. If omitted, the value is displayed as plain text"
        },
        "display_value": {
          "type": "string",
          "description": "The human-readable text to display instead of the raw value"
        }
      },
      "required": [
        "display_value"
      ],
      "type": "object"
    },
    "ValueMappingDisplayConfig": {
      "description": "Discriminated union of all display configuration types.\n\nAvailable display styles:\n- chip: Compact pill-shaped element with optional icon\n- label: Simple coloured text\n- badge: Prominent indicator, often circular or rectangular",
      "anyOf": [
        {
          "$ref": "#/definitions/ChipValueMappingDisplayConfig"
        },
        {
          "$ref": "#/definitions/LabelValueMappingDisplayConfig"
        },
        {
          "$ref": "#/definitions/BadgeValueMappingDisplayConfig"
        }
      ],
      "discriminator": {
        "propertyName": "type",
        "mapping": {
          "chip": "#/definitions/ChipValueMappingDisplayConfig",
          "label": "#/definitions/LabelValueMappingDisplayConfig",
          "badge": "#/definitions/BadgeValueMappingDisplayConfig"
        }
      }
    },
    "ChipValueMappingDisplayConfig": {
      "description": "Display configuration for chip-style rendering. Chips are compact UI elements with optional icons, typically used for tags, statuses, or categories",
      "additionalProperties": false,
      "properties": {
        "details": {
          "additionalProperties": false,
          "properties": {
            "color": {
              "type": "string",
              "description": "Chip colour (CSS colour string). Examples: 'red', '#ff0000', 'rgb(255, 0, 0)'"
            },
            "icon": {
              "type": "string",
              "description": "Icon identifier to display in the chip. Examples: 'check', 'alert', 'info'. The specific icon set is determined by the rendering engine"
            }
          },
          "type": "object",
          "description": "Optional chip-specific styling"
        },
        "type": {
          "const": "chip",
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "LabelValueMappingDisplayConfig": {
      "description": "Display configuration for label-style rendering. Labels are simple text with optional colouring, used for inline annotations",
      "additionalProperties": false,
      "properties": {
        "details": {
          "additionalProperties": false,
          "properties": {
            "color": {
              "type": "string",
              "description": "Label text colour (CSS colour string). Examples: 'blue', '#0000ff'"
            }
          },
          "type": "object",
          "description": "Optional label-specific styling"
        },
        "type": {
          "const": "label",
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "BadgeValueMappingDisplayConfig": {
      "description": "Display configuration for badge-style rendering. Badges are prominent indicators, typically used for counts or status indicators",
      "additionalProperties": false,
      "properties": {
        "details": {
          "additionalProperties": false,
          "properties": {
            "color": {
              "type": "string",
              "description": "Badge colour (CSS colour string). Examples: 'green', '#00ff00'"
            }
          },
          "type": "object",
          "description": "Optional badge-specific styling"
        },
        "type": {
          "const": "badge",
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "FilterCondition": {
      "description": "A filter condition can be either a relational comparison or a logical combination. This recursive structure enables arbitrarily complex filter expressions",
      "anyOf": [
        {
          "$ref": "#/definitions/LogicalFilterCondition"
        },
        {
          "$ref": "#/definitions/RelationalFilterCondition"
        }
      ],
      "discriminator": {
        "propertyName": "type",
        "mapping": {
          "logical": "#/definitions/LogicalFilterCondition",
          "relational": "#/definitions/RelationalFilterCondition"
        }
      }
    },
    "LogicalFilterCondition": {
      "description": "Combines multiple filter conditions using logical operators.\n\nEnables complex queries like:\n- (age > 18 AND country = 'UK') OR (status = 'verified')\n- NOT (deleted = true)\n\nConditions can be nested arbitrarily deep for sophisticated filtering",
      "additionalProperties": false,
      "properties": {
        "conditions": {
          "items": {
            "$ref": "#/definitions/FilterCondition"
          },
          "type": "array",
          "description": "Child conditions to combine. Can include both relational and other logical conditions (recursive)"
        },
        "operator": {
          "$ref": "#/definitions/FilterConditionLogicalOperator"
        },
        "type": {
          "const": "logical",
          "type": "string"
        }
      },
      "required": [
        "type",
        "operator",
        "conditions"
      ],
      "type": "object"
    },
    "RelationalFilterCondition": {
      "description": "A single field-value comparison.\n\nExample: {type: 'relational', field: {accessor: 'age'}, operator: 'greater_than', value: {type: 'value', value: 18}}",
      "additionalProperties": false,
      "properties": {
        "field": {
          "$ref": "#/definitions/AffordedField"
        },
        "operator": {
          "$ref": "#/definitions/FilterConditionRelationalOperator"
        },
        "type": {
          "const": "relational",
          "type": "string"
        },
        "value": {
          "$ref": "#/definitions/FilterConditionValue",
          "description": "What to compare the field against"
        }
      },
      "required": [
        "type",
        "field",
        "operator",
        "value"
      ],
      "type": "object"
    },
    "FilterConditionValue": {
      "description": "The value side of a filter comparison. Can be a literal value, reference to another field, list, or range",
      "anyOf": [
        {
          "$ref": "#/definitions/ValueFilterConditionValue"
        },
        {
          "$ref": "#/definitions/FieldFilterConditionValue"
        },
        {
          "$ref": "#/definitions/ListFilterConditionValue"
        },
        {
          "$ref": "#/definitions/RangeFilterConditionValue"
        }
      ],
      "discriminator": {
        "propertyName": "type",
        "mapping": {
          "value": "#/definitions/ValueFilterConditionValue",
          "field": "#/definitions/FieldFilterConditionValue",
          "list": "#/definitions/ListFilterConditionValue",
          "range": "#/definitions/RangeFilterConditionValue"
        }
      }
    },
    "ValueFilterConditionValue": {
      "description": "A literal value to compare against",
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "value",
          "type": "string"
        },
        "value": {
          "type": [
            "string",
            "number",
            "boolean",
            "null"
          ],
          "description": "The literal value to compare"
        }
      },
      "required": [
        "type",
        "value"
      ],
      "type": "object"
    },
    "FieldFilterConditionValue": {
      "description": "Reference to another field's value for field-to-field comparison.\n\nExample: Filter rows where 'end_date' > 'start_date'",
      "additionalProperties": false,
      "properties": {
        "field": {
          "$ref": "#/definitions/AffordedField"
        },
        "type": {
          "const": "field",
          "type": "string"
        }
      },
      "required": [
        "type",
        "field"
      ],
      "type": "object"
    },
    "ListFilterConditionValue": {
      "description": "A list of values for 'in' or 'not_in' operators",
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "list",
          "type": "string"
        },
        "values": {
          "items": {
            "type": [
              "string",
              "number",
              "boolean",
              "null"
            ]
          },
          "type": "array",
          "description": "The list of acceptable values"
        }
      },
      "required": [
        "type",
        "values"
      ],
      "type": "object"
    },
    "RangeFilterConditionValue": {
      "description": "A numeric or date range for 'between' operator. Both start and end are inclusive",
      "additionalProperties": false,
      "properties": {
        "end": {
          "type": [
            "string",
            "number"
          ],
          "description": "Range end (inclusive)"
        },
        "start": {
          "type": [
            "string",
            "number"
          ],
          "description": "Range start (inclusive)"
        },
        "type": {
          "const": "range",
          "type": "string"
        }
      },
      "required": [
        "type",
        "start",
        "end"
      ],
      "type": "object"
    },
    "LayoutNode": {
      "description": "A layout node defines how child elements are arranged spatially. Can be either a stack layout (linear arrangement) or grid layout (two-dimensional arrangement)",
      "anyOf": [
        {
          "$ref": "#/definitions/StackLayoutNode"
        },
        {
          "$ref": "#/definitions/GridLayoutNode"
        }
      ],
      "discriminator": {
        "propertyName": "type",
        "mapping": {
          "stack": "#/definitions/StackLayoutNode",
          "grid": "#/definitions/GridLayoutNode"
        }
      }
    },
    "StackLayoutNode": {
      "description": "Linear layout that arranges children in a single row or column.\n\nStack layouts are simpler than grids and ideal for:\n- Toolbars and navigation\n- Form fields in sequence\n- Card lists\n- Any linear arrangement of components\n\nAlignment works on two axes:\n- Primary axis (direction of flow): controlled by spacing and flex behaviour\n- Cross axis: controlled by horizontal_alignment (for vertical stacks) or vertical_alignment (for horizontal stacks)",
      "anyOf": [
        {
          "$ref": "#/definitions/HorizontalStackLayoutNode"
        },
        {
          "$ref": "#/definitions/VerticalStackLayoutNode"
        }
      ],
      "discriminator": {
        "propertyName": "direction",
        "mapping": {
          "horizontal": "#/definitions/HorizontalStackLayoutNode",
          "vertical": "#/definitions/VerticalStackLayoutNode"
        }
      }
    },
    "HorizontalStackLayoutNode": {
      "description": "Horizontal stack layout - arranges children left-to-right.\n\nCommon properties:\n- Size constraints work together: if only width is set, it defines the exact or preferred width. If min_width and max_width are set, they bound the width range. The final size is calculated by the rendering engine based on constraints and content",
      "additionalProperties": false,
      "properties": {
        "children": {
          "items": {
            "$ref": "#/definitions/LayoutChild"
          },
          "type": "array",
          "description": "Ordered list of children to render in sequence"
        },
        "direction": {
          "const": "horizontal",
          "type": "string",
          "description": "Flow direction of children - fixed to 'horizontal' for this layout type"
        },
        "height": {
          "$ref": "#/definitions/SizeConstraint"
        },
        "id": {
          "type": "string",
          "description": "Unique identifier for this layout node"
        },
        "max_height": {
          "$ref": "#/definitions/SizeConstraint"
        },
        "max_width": {
          "$ref": "#/definitions/SizeConstraint"
        },
        "min_height": {
          "$ref": "#/definitions/SizeConstraint"
        },
        "min_width": {
          "$ref": "#/definitions/SizeConstraint"
        },
        "padding": {
          "$ref": "#/definitions/Padding"
        },
        "spacing": {
          "$ref": "#/definitions/LayoutNodeSpacing"
        },
        "type": {
          "const": "stack",
          "type": "string",
          "description": "Discriminator value for stack layouts"
        },
        "vertical_alignment": {
          "$ref": "#/definitions/StackLayoutNodeAlignment"
        },
        "width": {
          "$ref": "#/definitions/SizeConstraint"
        }
      },
      "required": [
        "children",
        "direction",
        "id",
        "spacing",
        "type"
      ],
      "type": "object"
    },
    "VerticalStackLayoutNode": {
      "description": "Vertical stack layout - arranges children top-to-bottom.\n\nCommon properties:\n- Size constraints work together: if only width is set, it defines the exact or preferred width. If min_width and max_width are set, they bound the width range. The final size is calculated by the rendering engine based on constraints and content",
      "additionalProperties": false,
      "properties": {
        "children": {
          "items": {
            "$ref": "#/definitions/LayoutChild"
          },
          "type": "array",
          "description": "Ordered list of children to render in sequence"
        },
        "direction": {
          "const": "vertical",
          "type": "string",
          "description": "Flow direction of children - fixed to 'vertical' for this layout type"
        },
        "height": {
          "$ref": "#/definitions/SizeConstraint"
        },
        "horizontal_alignment": {
          "$ref": "#/definitions/StackLayoutNodeAlignment"
        },
        "id": {
          "type": "string",
          "description": "Unique identifier for this layout node"
        },
        "max_height": {
          "$ref": "#/definitions/SizeConstraint"
        },
        "max_width": {
          "$ref": "#/definitions/SizeConstraint"
        },
        "min_height": {
          "$ref": "#/definitions/SizeConstraint"
        },
        "min_width": {
          "$ref": "#/definitions/SizeConstraint"
        },
        "padding": {
          "$ref": "#/definitions/Padding"
        },
        "spacing": {
          "$ref": "#/definitions/LayoutNodeSpacing"
        },
        "type": {
          "const": "stack",
          "type": "string",
          "description": "Discriminator value for stack layouts"
        },
        "width": {
          "$ref": "#/definitions/SizeConstraint"
        }
      },
      "required": [
        "children",
        "direction",
        "id",
        "spacing",
        "type"
      ],
      "type": "object"
    },
    "GridLayoutNode": {
      "description": "Grid layout that arranges children in rows and columns.\n\nGrid layouts provide precise two-dimensional control and are ideal for:\n- Dashboard layouts\n- Form layouts with labels and inputs\n- Card grids\n- Any content requiring alignment on both axes\n\nGrid supports both auto-flow (children placed automatically) and explicit positioning (using column_start/row_start on GridChild)",
      "additionalProperties": false,
      "properties": {
        "children": {
          "items": {
            "$ref": "#/definitions/GridChild"
          },
          "type": "array",
          "description": "Children with optional positioning and spanning information"
        },
        "column_gap": {
          "$ref": "#/definitions/LayoutNodeSpacing"
        },
        "columns": {
          "type": "number",
          "description": "Number of columns in the grid"
        },
        "height": {
          "$ref": "#/definitions/SizeConstraint"
        },
        "id": {
          "type": "string",
          "description": "Unique identifier for this layout node"
        },
        "max_height": {
          "$ref": "#/definitions/SizeConstraint"
        },
        "max_width": {
          "$ref": "#/definitions/SizeConstraint"
        },
        "min_height": {
          "$ref": "#/definitions/SizeConstraint"
        },
        "min_width": {
          "$ref": "#/definitions/SizeConstraint"
        },
        "padding": {
          "$ref": "#/definitions/Padding"
        },
        "row_gap": {
          "$ref": "#/definitions/LayoutNodeSpacing"
        },
        "rows": {
          "type": "number",
          "description": "Optional number of rows. If omitted, rows are created automatically as needed (auto-flow)"
        },
        "type": {
          "const": "grid",
          "type": "string",
          "description": "Discriminator value for grid layouts"
        },
        "width": {
          "$ref": "#/definitions/SizeConstraint"
        }
      },
      "required": [
        "children",
        "columns",
        "id",
        "type"
      ],
      "type": "object"
    },
    "GridChild": {
      "description": "A child within a grid layout with optional positioning and spanning.\n\nPositioning modes:\n- Auto-flow (default): Omit column_start and row_start - child is placed in the next available cell\n- Explicit: Set column_start and row_start to place child at a specific grid position\n\nGrid coordinates are 1-indexed (first column is 1, not 0)",
      "additionalProperties": false,
      "properties": {
        "column_span": {
          "type": "number",
          "description": "Number of columns this child spans. Default: 1"
        },
        "column_start": {
          "type": "number",
          "description": "Explicit column position (1-indexed). Omit to use auto-flow positioning"
        },
        "element": {
          "$ref": "#/definitions/LayoutChild",
          "description": "The layout or component to render in this grid cell"
        },
        "row_span": {
          "type": "number",
          "description": "Number of rows this child spans. Default: 1"
        },
        "row_start": {
          "type": "number",
          "description": "Explicit row position (1-indexed). Omit to use auto-flow positioning"
        }
      },
      "required": [
        "element"
      ],
      "type": "object"
    },
    "LayoutChild": {
      "description": "A child element within a layout.\n\nCan be either:\n- Another layout node (enabling nested/composable layouts)\n- A component (leaf node referenced by ID from ComponentSpec.components)\n\nThis discriminated union enables type-safe handling of the two cases",
      "anyOf": [
        {
          "$ref": "#/definitions/LayoutLayoutChild"
        },
        {
          "$ref": "#/definitions/ComponentLayoutChild"
        }
      ],
      "discriminator": {
        "propertyName": "type",
        "mapping": {
          "layout": "#/definitions/LayoutLayoutChild",
          "component": "#/definitions/ComponentLayoutChild"
        }
      }
    },
    "LayoutLayoutChild": {
      "description": "Nested layout node for hierarchical composition",
      "additionalProperties": false,
      "properties": {
        "node": {
          "$ref": "#/definitions/LayoutNode",
          "description": "The nested layout node"
        },
        "type": {
          "const": "layout",
          "type": "string"
        }
      },
      "required": [
        "type",
        "node"
      ],
      "type": "object"
    },
    "ComponentLayoutChild": {
      "description": "Reference to a component by its ID. The component must exist in ComponentSpec.components",
      "additionalProperties": false,
      "properties": {
        "component_id": {
          "type": "string",
          "description": "ID of the component to render"
        },
        "type": {
          "const": "component",
          "type": "string"
        }
      },
      "required": [
        "type",
        "component_id"
      ],
      "type": "object"
    },
    "DataType": {
      "description": "Supported data types for field values. These types are used for type validation, coercion, and determining appropriate display components (e.g., date pickers for dates).\n\nAvailable types:\n- number: Numeric values (integers and floats)\n- string: Text values\n- date: Temporal values (dates, timestamps)\n- boolean: Boolean true/false\n- null: Explicit null values\n- array: Array/list structures\n- object: Nested object structures\n- undefined: Undefined/missing values\n- unknown: Unknown or mixed types",
      "enum": [
        "number",
        "string",
        "date",
        "boolean",
        "null",
        "array",
        "object",
        "undefined",
        "unknown"
      ],
      "type": "string"
    },
    "DataShape": {
      "description": "Describes the structural pattern of the source data being visualised. This is NOT about how data is displayed, but about the inherent structure of the input data. Helps validate data compatibility with the spec and informs appropriate component selection.\n\nAvailable shapes:\n- tabular: Tabular data with rows and columns (e.g., CSV, database tables, spreadsheets)\n- hierarchical: Nested or tree-like structures (e.g., JSON with nested objects, file systems, organisational charts)\n- key_value: Flat key-value pairs (e.g., configuration files, environment variables, metadata)\n- graph: Network structures with nodes and edges (e.g., social networks, dependency graphs, knowledge graphs)\n- geospatial: Location-based data with coordinates (e.g., GeoJSON, GPS data, spatial datasets)",
      "enum": [
        "tabular",
        "hierarchical",
        "key_value",
        "graph",
        "geospatial"
      ],
      "type": "string"
    },
    "ComponentType": {
      "description": "Available component types, each optimised for specific data shapes. Components are the 'rendering primitives' of the specification system. Each type is designed to handle a particular visualisation pattern.\n\nAvailable types:\n- data-table: Tabular display with rows and columns (best for: tabular data shapes, spreadsheet-like views, data grids)\n- hierarchy: Tree or nested structure display (best for: hierarchical data shapes, file explorers, org charts, JSON viewers)\n- composition: Composed/aggregate visualisations combining multiple sub-components (best for: dashboards, multi-faceted views, complex analytical displays)\n- text-insight: Text-based insights, summaries, or explanations (best for: key_value data shapes, insights, summaries, explanatory text)",
      "enum": [
        "data-table",
        "hierarchy",
        "composition",
        "text-insight"
      ],
      "type": "string"
    },
    "ExportAffordanceFormat": {
      "description": "Supported export file formats.\n\nAvailable formats:\n- csv: Comma-separated values (tabular data)\n- json: JSON array of objects",
      "enum": [
        "csv",
        "json"
      ],
      "type": "string"
    },
    "FilterType": {
      "description": "Filter interaction types that determine appropriate interaction patterns.\n\nAvailable types:\n- text: Text-based filtering with string matching (contains, starts with, equals, etc.)\n- number_range: Numeric range filtering with min/max bounds\n- date_range: Date range filtering with start/end dates\n- select: Selection from predefined options (derived from unique field values)\n- boolean: Boolean filtering",
      "enum": [
        "text",
        "number_range",
        "date_range",
        "select",
        "boolean"
      ],
      "type": "string"
    },
    "FilterConditionLogicalOperator": {
      "description": "Logical operators for combining multiple filter conditions.\n\nAvailable operators:\n- and: All conditions must be true (intersection)\n- or: At least one condition must be true (union)\n- not: Negates the child condition(s)",
      "enum": [
        "and",
        "or",
        "not"
      ],
      "type": "string"
    },
    "FilterConditionRelationalOperator": {
      "description": "Comparison operators for relational filter conditions.\n\nAvailable operators:\n- equals: Exact equality (field === value)\n- not_equals: Inequality (field !== value)\n- contains: String contains substring (case-insensitive recommended)\n- not_contains: String does not contain substring\n- starts_with: String starts with prefix\n- ends_with: String ends with suffix\n- greater_than: Numeric/date comparison (field > value)\n- less_than: Numeric/date comparison (field < value)\n- greater_than_or_equal: Numeric/date comparison (field >= value)\n- less_than_or_equal: Numeric/date comparison (field <= value)\n- between: Value is within a range (inclusive) - use with RangeFilterConditionValue\n- in: Value is in a list of options - use with ListFilterConditionValue\n- not_in: Value is not in a list of options - use with ListFilterConditionValue",
      "enum": [
        "equals",
        "not_equals",
        "contains",
        "not_contains",
        "starts_with",
        "ends_with",
        "greater_than",
        "less_than",
        "greater_than_or_equal",
        "less_than_or_equal",
        "between",
        "in",
        "not_in"
      ],
      "type": "string"
    },
    "LayoutNodeSpacing": {
      "description": "Predefined spacing scales for consistent visual rhythm.\n\nAvailable spacings:\n- tight: Minimal spacing for dense layouts\n- normal: Default spacing for balanced layouts\n- relaxed: Generous spacing for spacious layouts",
      "enum": [
        "tight",
        "normal",
        "relaxed"
      ],
      "type": "string"
    },
    "StackLayoutNodeAlignment": {
      "description": "Alignment options for stack layout children along the cross axis.\n\nAvailable alignments:\n- start: Align to the start (left/top)\n- center: Align to the center\n- end: Align to the end (right/bottom)\n- stretch: Stretch to fill the cross axis",
      "enum": [
        "start",
        "center",
        "end",
        "stretch"
      ],
      "type": "string"
    },
    "Padding": {
      "description": "Flexible padding definition supporting shorthand and explicit sides. Follows CSS-like conventions for ease of use.\n\nCan be either:\n- A number: Same padding on all four sides (top, right, bottom, left)\n- An object: Specify each side independently (omitted sides default to 0)",
      "anyOf": [
        {
          "type": "number"
        },
        {
          "additionalProperties": false,
          "properties": {
            "bottom": {
              "type": "number"
            },
            "left": {
              "type": "number"
            },
            "right": {
              "type": "number"
            },
            "top": {
              "type": "number"
            }
          },
          "type": "object"
        }
      ]
    },
    "AffordedField": {
      "description": "Reference to a field in the provided data using an accessor path.\n\nAccessor syntax:\n- Simple field: 'name', 'age', 'status'\n- Nested field: 'user.profile.email', 'metadata.created_at'\n- Array index: 'items[0]', 'users[5].name'\n- Mixed: 'data.users[0].contacts[1].email'\n\nThe accessor is resolved at inference time against the provided data.",
      "additionalProperties": false,
      "properties": {
        "accessor": {
          "type": "string",
          "description": "Dot-notation path to the field in the data. Supports nested objects and array indexing"
        }
      },
      "required": [
        "accessor"
      ],
      "type": "object"
    },
    "SizeConstraint": {
      "description": "Defines how an element's size is calculated. Different constraint types enable different layout behaviours:\n- Use 'fixed' for exact pixel dimensions (e.g., icons, buttons)\n- Use 'flex' for proportional sizing (e.g., sidebar vs main content)\n- Use 'percentage' for responsive layouts (e.g., 50% width)\n- Use 'content' to size based on children (e.g., auto-sizing containers)",
      "anyOf": [
        {
          "$ref": "#/definitions/FixedSizeConstraint"
        },
        {
          "$ref": "#/definitions/FlexSizeConstraint"
        },
        {
          "$ref": "#/definitions/PercentageSizeConstraint"
        },
        {
          "$ref": "#/definitions/ContentSizeConstraint"
        }
      ],
      "discriminator": {
        "propertyName": "type",
        "mapping": {
          "fixed": "#/definitions/FixedSizeConstraint",
          "flex": "#/definitions/FlexSizeConstraint",
          "percentage": "#/definitions/PercentageSizeConstraint",
          "content": "#/definitions/ContentSizeConstraint"
        }
      }
    },
    "FixedSizeConstraint": {
      "description": "Fixed size in pixels. The element will be exactly this size regardless of content or container",
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "fixed",
          "type": "string"
        },
        "value": {
          "type": "number",
          "description": "Size in pixels"
        }
      },
      "required": [
        "type",
        "value"
      ],
      "type": "object"
    },
    "FlexSizeConstraint": {
      "description": "Flex sizing with a flex factor. Element shares available space proportionally with other flex elements. E.g., flex: 1 and flex: 2 would give 33% and 67% of space respectively",
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "flex",
          "type": "string"
        },
        "value": {
          "type": "number",
          "description": "Flex factor for proportional sizing"
        }
      },
      "required": [
        "type",
        "value"
      ],
      "type": "object"
    },
    "PercentageSizeConstraint": {
      "description": "Percentage of parent container size. Value should be between 0 and 100",
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "percentage",
          "type": "string"
        },
        "value": {
          "type": "number",
          "description": "Percentage value (0-100)"
        }
      },
      "required": [
        "type",
        "value"
      ],
      "type": "object"
    },
    "ContentSizeConstraint": {
      "description": "Size to fit content. Element sizes based on its children's dimensions",
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "content",
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    }
  }
}
