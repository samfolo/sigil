{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "sigil://spec/primitives",
  "title": "Sigil Primitives",
  "description": "Basic types, enums, and shared primitives used across the Sigil specification",
  "definitions": {
    "DataType": {
      "description": "Supported data types for field values. These types are used for type validation, coercion, and determining appropriate display components (e.g., date pickers for dates).\n\nAvailable types:\n- number: Numeric values (integers and floats)\n- string: Text values\n- date: Temporal values (dates, timestamps)\n- boolean: Boolean true/false\n- null: Explicit null values\n- array: Array/list structures\n- object: Nested object structures\n- undefined: Undefined/missing values\n- unknown: Unknown or mixed types",
      "enum": [
        "number",
        "string",
        "date",
        "boolean",
        "null",
        "array",
        "object",
        "undefined",
        "unknown"
      ],
      "type": "string"
    },
    "DataShape": {
      "description": "Describes the structural pattern of the source data being visualised. This is NOT about how data is displayed, but about the inherent structure of the input data. Helps validate data compatibility with the spec and informs appropriate component selection.\n\nAvailable shapes:\n- tabular: Tabular data with rows and columns (e.g., CSV, database tables, spreadsheets)\n- hierarchical: Nested or tree-like structures (e.g., JSON with nested objects, file systems, organisational charts)\n- key_value: Flat key-value pairs (e.g., configuration files, environment variables, metadata)\n- graph: Network structures with nodes and edges (e.g., social networks, dependency graphs, knowledge graphs)\n- geospatial: Location-based data with coordinates (e.g., GeoJSON, GPS data, spatial datasets)",
      "enum": [
        "tabular",
        "hierarchical",
        "key_value",
        "graph",
        "geospatial"
      ],
      "type": "string"
    },
    "ComponentType": {
      "description": "Available component types, each optimised for specific data shapes. Components are the 'rendering primitives' of the specification system. Each type is designed to handle a particular visualisation pattern.\n\nAvailable types:\n- data-table: Tabular display with rows and columns (best for: tabular data shapes, spreadsheet-like views, data grids)\n- hierarchy: Tree or nested structure display (best for: hierarchical data shapes, file explorers, org charts, JSON viewers)\n- composition: Composed/aggregate visualisations combining multiple sub-components (best for: dashboards, multi-faceted views, complex analytical displays)\n- text-insight: Text-based insights, summaries, or explanations (best for: key_value data shapes, insights, summaries, explanatory text)\n- text: Atomic text primitive for rendering single bound values with formatting and styling",
      "enum": [
        "data-table",
        "hierarchy",
        "composition",
        "text-insight",
        "text"
      ],
      "type": "string"
    },
    "ExportAffordanceFormat": {
      "description": "Supported export file formats.\n\nAvailable formats:\n- csv: Comma-separated values (tabular data)\n- json: JSON array of objects",
      "enum": [
        "csv",
        "json"
      ],
      "type": "string"
    },
    "FilterType": {
      "description": "Filter interaction types that determine appropriate interaction patterns.\n\nAvailable types:\n- text: Text-based filtering with string matching (contains, starts with, equals, etc.)\n- number_range: Numeric range filtering with min/max bounds\n- date_range: Date range filtering with start/end dates\n- select: Selection from predefined options (derived from unique field values)\n- boolean: Boolean filtering",
      "enum": [
        "text",
        "number_range",
        "date_range",
        "select",
        "boolean"
      ],
      "type": "string"
    },
    "FilterConditionLogicalOperator": {
      "description": "Logical operators for combining multiple filter conditions.\n\nAvailable operators:\n- and: All conditions must be true (intersection)\n- or: At least one condition must be true (union)\n- not: Negates the child condition(s)",
      "enum": [
        "and",
        "or",
        "not"
      ],
      "type": "string"
    },
    "FilterConditionRelationalOperator": {
      "description": "Comparison operators for relational filter conditions.\n\nAvailable operators:\n- equals: Exact equality (field === value)\n- not_equals: Inequality (field !== value)\n- contains: String contains substring (case-insensitive recommended)\n- not_contains: String does not contain substring\n- starts_with: String starts with prefix\n- ends_with: String ends with suffix\n- greater_than: Numeric/date comparison (field > value)\n- less_than: Numeric/date comparison (field < value)\n- greater_than_or_equal: Numeric/date comparison (field >= value)\n- less_than_or_equal: Numeric/date comparison (field <= value)\n- between: Value is within a range (inclusive) - use with RangeFilterConditionValue\n- in: Value is in a list of options - use with ListFilterConditionValue\n- not_in: Value is not in a list of options - use with ListFilterConditionValue",
      "enum": [
        "equals",
        "not_equals",
        "contains",
        "not_contains",
        "starts_with",
        "ends_with",
        "greater_than",
        "less_than",
        "greater_than_or_equal",
        "less_than_or_equal",
        "between",
        "in",
        "not_in"
      ],
      "type": "string"
    },
    "LayoutNodeSpacing": {
      "description": "Predefined spacing scales for consistent visual rhythm.\n\nAvailable spacings:\n- tight: Minimal spacing for dense layouts\n- normal: Default spacing for balanced layouts\n- relaxed: Generous spacing for spacious layouts",
      "enum": [
        "tight",
        "normal",
        "relaxed"
      ],
      "type": "string"
    },
    "StackLayoutNodeAlignment": {
      "description": "Alignment options for stack layout children along the cross axis.\n\nAvailable alignments:\n- start: Align to the start (left/top)\n- center: Align to the center\n- end: Align to the end (right/bottom)\n- stretch: Stretch to fill the cross axis",
      "enum": [
        "start",
        "center",
        "end",
        "stretch"
      ],
      "type": "string"
    },
    "Padding": {
      "description": "Flexible padding definition supporting shorthand and explicit sides. Follows CSS-like conventions for ease of use.\n\nCan be either:\n- A number: Same padding on all four sides (top, right, bottom, left)\n- An object: Specify each side independently (omitted sides default to 0)",
      "anyOf": [
        {
          "type": "number"
        },
        {
          "additionalProperties": false,
          "properties": {
            "bottom": {
              "type": "number"
            },
            "left": {
              "type": "number"
            },
            "right": {
              "type": "number"
            },
            "top": {
              "type": "number"
            }
          },
          "type": "object"
        }
      ]
    },
    "AffordedField": {
      "description": "Reference to a field in the provided data using a JSONPath accessor.\n\nAll accessors MUST use valid JSONPath syntax with the `$` root prefix.\n\nSupported JSONPath features:\n- Simple fields: '$.name', '$.age', '$.status'\n- Nested fields: '$.user.profile.email', '$.metadata.created_at'\n- Array indexing: '$.items[0]', '$.users[5].name'\n- Mixed: '$.data.users[0].contacts[1].email'\n- Wildcards: '$..book[*]' (all books recursively)\n- Filters: '$..book[?(@.price < 10)]' (books under Â£10)\n- Recursive descent: '$..author' (all author fields at any depth)\n\nThe accessor is resolved at render time using jsonpath-plus.",
      "additionalProperties": false,
      "properties": {
        "accessor": {
          "type": "string",
          "description": "JSONPath expression (must start with `$`). Supports full JSONPath specification including wildcards, filters, and recursive descent."
        }
      },
      "required": [
        "accessor"
      ],
      "type": "object"
    },
    "SizeConstraint": {
      "description": "Defines how an element's size is calculated. Different constraint types enable different layout behaviours:\n- Use 'fixed' for exact pixel dimensions (e.g., icons, buttons)\n- Use 'flex' for proportional sizing (e.g., sidebar vs main content)\n- Use 'percentage' for responsive layouts (e.g., 50% width)\n- Use 'content' to size based on children (e.g., auto-sizing containers)",
      "anyOf": [
        {
          "$ref": "#/definitions/FixedSizeConstraint"
        },
        {
          "$ref": "#/definitions/FlexSizeConstraint"
        },
        {
          "$ref": "#/definitions/PercentageSizeConstraint"
        },
        {
          "$ref": "#/definitions/ContentSizeConstraint"
        }
      ],
      "discriminator": {
        "propertyName": "type",
        "mapping": {
          "fixed": "#/definitions/FixedSizeConstraint",
          "flex": "#/definitions/FlexSizeConstraint",
          "percentage": "#/definitions/PercentageSizeConstraint",
          "content": "#/definitions/ContentSizeConstraint"
        }
      }
    },
    "FixedSizeConstraint": {
      "description": "Fixed size in pixels. The element will be exactly this size regardless of content or container",
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "fixed",
          "type": "string"
        },
        "value": {
          "type": "number",
          "description": "Size in pixels"
        }
      },
      "required": [
        "type",
        "value"
      ],
      "type": "object"
    },
    "FlexSizeConstraint": {
      "description": "Flex sizing with a flex factor. Element shares available space proportionally with other flex elements. E.g., flex: 1 and flex: 2 would give 33% and 67% of space respectively",
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "flex",
          "type": "string"
        },
        "value": {
          "type": "number",
          "description": "Flex factor for proportional sizing"
        }
      },
      "required": [
        "type",
        "value"
      ],
      "type": "object"
    },
    "PercentageSizeConstraint": {
      "description": "Percentage of parent container size. Value should be between 0 and 100",
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "percentage",
          "type": "string"
        },
        "value": {
          "type": "number",
          "description": "Percentage value (0-100)"
        }
      },
      "required": [
        "type",
        "value"
      ],
      "type": "object"
    },
    "ContentSizeConstraint": {
      "description": "Size to fit content. Element sizes based on its children's dimensions",
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "content",
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "TextScale": {
      "description": "Semantic importance levels for text. These represent hierarchy and emphasis, not visual sizes. Renderers map to platform-appropriate typography.\n\nAvailable scales:\n- display: Largest, most prominent text (hero headings, splash screens)\n- title: Primary page or section titles\n- heading: Section headings within content\n- subheading: Secondary headings, group labels\n- body: Standard paragraph text (default)\n- caption: Supporting text, annotations, timestamps\n- overline: Small uppercase labels above headings",
      "enum": [
        "display",
        "title",
        "heading",
        "subheading",
        "body",
        "caption",
        "overline"
      ],
      "type": "string"
    },
    "TextTrait": {
      "description": "Semantic text traits for styling. Traits are combinable (used as array) and represent meaning, not visual appearance. Renderers map to platform-appropriate styling.\n\nAvailable traits:\n- strong: Important or emphasised content (typically bold)\n- emphasis: Stressed content (typically italic)\n- code: Monospace text for code, commands, or technical content\n- underline: Underlined text (use sparingly, often implies links)\n- subtle: De-emphasised or secondary content (typically muted colour)\n- superscript: Raised text (footnotes, ordinals, mathematical notation)\n- subscript: Lowered text (chemical formulas, mathematical notation)",
      "enum": [
        "strong",
        "emphasis",
        "code",
        "underline",
        "subtle",
        "superscript",
        "subscript"
      ],
      "type": "string"
    }
  }
}
